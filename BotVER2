import json
import logging
import os
import re
import asyncio
import time

from aiogram import Bot, Dispatcher, types
from aiogram.enums import ParseMode
from aiogram.types import Message
from aiogram.filters import CommandStart
from aiogram.client.default import DefaultBotProperties
from telethon import TelegramClient, events
from telethon.tl.functions.messages import SendReactionRequest
from telethon.tl.types import ReactionEmoji

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–æ–≤
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# –°–ø–∏—Å–æ–∫ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã—Ö –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
IGNORED_USERS = {1231231231, 12312123}


# API-—Ç–æ–∫–µ–Ω –¥–ª—è Aiogram
API_TOKEN = "123231212"

# –î–∞–Ω–Ω—ã–µ UserBot
API_ID = "123121231231"
API_HASH = "1231231221"
USERBOT_SESSION = "userbot_session"

# –ß–∞—Ç—ã
SOURCE_CHAT_ID = 12312312  # CB
TARGET_CHAT_USERBOT = 123121  # –ß–∞—Ç, –≥–¥–µ –æ—Ç–≤–µ—á–∞–µ—Ç —Ç–æ–ª—å–∫–æ UserBot

# –§–∞–π–ª –¥–ª—è –∫—ç—à–∞
CACHE_FILE = "cache.json"

# –ë–æ—Ç –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä
bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()

# –ü–æ–¥–∫–ª—é—á–∞–µ–º Telethon UserBot
client = TelegramClient(USERBOT_SESSION, API_ID, API_HASH)

# –ö—ç—à —Å–æ–æ–±—â–µ–Ω–∏–π {ID: {"status": ..., "timestamp": ..., "pending_replies": [(chat_id, message_id)]}}
cache = {}

def load_cache():
    global cache
    if os.path.exists(CACHE_FILE):
        try:
            with open(CACHE_FILE, "r", encoding="utf-8") as f:
                cache = json.load(f)
            logging.info("–ö—ç—à –∑–∞–≥—Ä—É–∂–µ–Ω.")
        except Exception as e:
            logging.error(f"‚ö† –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫—ç—à–∞: {e}")
            cache = {}


# –§—É–Ω–∫—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫—ç—à–∞ –≤ —Ñ–∞–π–ª
def save_cache():
    try:
        with open(CACHE_FILE, "w", encoding="utf-8") as f:
            json.dump(cache, f, ensure_ascii=False, indent=4)
        logging.info("–ö—ç—à —Å–æ—Ö—Ä–∞–Ω–µ–Ω.")
    except Exception as e:
        logging.error(f"‚ö† –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫—ç—à–∞: {e}")


# –§—É–Ω–∫—Ü–∏—è –æ—á–∏—Å—Ç–∫–∏ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö id (—Å—Ç–∞—Ä—à–µ 24 —á–∞—Å–æ–≤)
def cleanup_cache():
    global cache
    now = time.time()
    cache = {
        k: v for k, v in cache.items()
        if now - v.get("timestamp", 0) < 86400
    }
    save_cache()


# –ó–∞–≥—Ä—É–∑–∫–∞ –∫—ç—à–∞ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
load_cache()


# –ö–æ–º–∞–Ω–¥–∞ /start
@dp.message(CommandStart())
async def start_command(message: Message):
    if message.from_user.id in IGNORED_USERS:
        logging.info(f"–ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—É /start –æ—Ç {message.from_user.id}")
        return
    await message.answer("‚úÖ")


# UserBot –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –≤ TARGET_CHAT_USERBOT
@client.on(events.NewMessage(chats=TARGET_CHAT_USERBOT))
async def userbot_target_chat_handler(event):
    if event.sender_id in IGNORED_USERS:
        logging.info(f"–ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {event.sender_id} –≤ TARGET_CHAT_USERBOT")
        return

    text = event.message.text if event.message.text else ""
    has_media = bool(event.message.media)

    logging.info(f"UserBot –ø–æ–ª—É—á–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ TARGET_CHAT_USERBOT: {text} (–§–∞–π–ª: {has_media})")

    found_ids = extract_ids(text)

    if not found_ids or not has_media:
        logging.info(f"‚ö† –°–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ (–Ω–µ—Ç ID –∏–ª–∏ —Ñ–∞–π–ª–∞).")
        return

    for id_value in found_ids:
        await handle_target_chat_id(id_value, TARGET_CHAT_USERBOT, event.message.id)


# UserBot –ø–æ–ª—É—á–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ SOURCE_CHAT
@client.on(events.NewMessage(chats=SOURCE_CHAT_ID))
async def userbot_message_handler(event):
    if event.sender_id in IGNORED_USERS:
        logging.info(f"–ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {event.sender_id} –≤ SOURCE_CHAT")
        return

    text = event.message.text if event.message.text else ""
    logging.info(f"UserBot –ø–æ–ª—É—á–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ SOURCE_CHAT: {text}")

    tracker_id_match = re.search(r"TrackerID:\s*`?([\w-]+)`?", text)
    client_id_match = re.search(r"ClientID:\s*`?([\w-]+)`?", text)
    status_match = re.search(r"C—Ç–∞—Ç—É—Å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏:\s*`?(—É—Å–ø–µ—Ö|–æ—à–∏–±–∫–∞)`?", text)

    tracker_id = tracker_id_match.group(1) if tracker_id_match else None
    client_id = client_id_match.group(1) if client_id_match else None
    status = status_match.group(1) if status_match else None

    if not tracker_id and not client_id:
        logging.warning("‚ö† –ù–µ –Ω–∞–π–¥–µ–Ω TrackerID –∏–ª–∏ ClientID, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º.")
        return

    logging.info(f"üîç –ù–∞–π–¥–µ–Ω TrackerID: {tracker_id}, ClientID: {client_id}, –°—Ç–∞—Ç—É—Å: {status}")

    if status == "–æ—à–∏–±–∫–∞":
        logging.info(f"‚ùå ID {tracker_id or client_id} –∏–º–µ–µ—Ç —Å—Ç–∞—Ç—É—Å '–æ—à–∏–±–∫–∞', –Ω–µ –∑–∞–ø–æ–º–∏–Ω–∞–µ–º.")
        return

    for id_value in [tracker_id, client_id]:
        if not id_value:
            continue

        now = time.time()
        if id_value not in cache:
            cache[id_value] = {
                "status": "—É—Å–ø–µ—Ö",
                "timestamp": now,
                "pending_replies": [],
                "responded_to": []
            }
        else:
            cache[id_value]["status"] = "—É—Å–ø–µ—Ö"
            cache[id_value]["timestamp"] = now

        pending_replies = cache[id_value].get("pending_replies", [])[:]
        cache[id_value]["pending_replies"] = []

        for chat_id, message_id in pending_replies:
            if (chat_id, message_id) in cache[id_value].get("responded_to", []):
                continue

            if chat_id == TARGET_CHAT_USERBOT:
                await client.send_message(chat_id, f"{id_value} –£—Å–ø–µ—Ö", reply_to=message_id)
                await add_reaction(chat_id, message_id)
                logging.info(f"‚úÖ UserBot –æ—Ç–ø—Ä–∞–≤–∏–ª '–£—Å–ø–µ—Ö' –≤ TARGET_CHAT_USERBOT")
            else:
                await bot.send_message(chat_id, f"{id_value} –£—Å–ø–µ—Ö", reply_to_message_id=message_id)
                logging.info(f"‚úÖ Aiogram –æ—Ç–ø—Ä–∞–≤–∏–ª '–£—Å–ø–µ—Ö' –≤ {chat_id}")

            cache[id_value].setdefault("responded_to", []).append((chat_id, message_id))

    logging.info(f"üóÉ –û–±–Ω–æ–≤–ª–µ–Ω –∫—ç—à: {cache}")


# Bot –ø–æ–ª—É—á–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –≤–æ –≤—Å–µ—Ö —á–∞—Ç–∞—Ö, –∫—Ä–æ–º–µ SOURCE_CHAT –∏ TARGET_CHAT_USERBOT
@dp.message()
async def handle_message(message: Message):
    if message.from_user.id in IGNORED_USERS:
        logging.info(f"–ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {message.from_user.id}")
        return

    chat_id = message.chat.id

    if chat_id in [SOURCE_CHAT_ID, TARGET_CHAT_USERBOT]:
        logging.info(f"–ë–æ—Ç –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ {chat_id}")
        return

    text = message.caption if message.caption else message.text
    has_media = bool(message.document or message.photo or message.video or message.audio or message.voice or message.sticker or message.video_note)

    if not text:
        logging.info(f"–ë–æ—Ç –ø–æ–ª—É—á–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ {chat_id}, –Ω–æ –æ–Ω–æ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–µ–∫—Å—Ç–∞.")
        return

    if not has_media:
        logging.info(f"‚ö† –°–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ {chat_id} –±–µ–∑ –º–µ–¥–∏–∞, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º.")
        return

    logging.info(f"–ë–æ—Ç –ø–æ–ª—É—á–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ {chat_id}: {text}")

    found_ids = extract_ids(text)

    if not found_ids:
        logging.info(f"‚ö† –í —Ç–µ–∫—Å—Ç–µ –Ω–µ—Ç ID, –±–æ—Ç –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç.")
        return

    longest_id = max(found_ids, key=len)  # –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ —Å–∞–º—ã–π –¥–ª–∏–Ω–Ω—ã–π ID
    await handle_target_chat_id(longest_id, chat_id, message.message_id)


# –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ ID
async def handle_target_chat_id(id_value, chat_id=None, message_id=None):
    now = time.time()

    if id_value not in cache:
        cache[id_value] = {
            "status": None,
            "timestamp": now,
            "pending_replies": [],
            "responded_to": []
        }
    else:
        cache[id_value]["timestamp"] = now

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–≤–µ—á–∞–ª–∏ –ª–∏ –º—ã —É–∂–µ –Ω–∞ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
    if (chat_id, message_id) in cache[id_value].get("responded_to", []):
        logging.info(f"‚è≠ –£–∂–µ –æ—Ç–≤–µ—á–∞–ª–∏ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å ID {id_value} –≤ {chat_id}, message {message_id}")
        return

    if cache[id_value]["status"] == "—É—Å–ø–µ—Ö":
        response_text = f"{id_value}\n–£—Å–ø–µ—Ö"

        if chat_id == TARGET_CHAT_USERBOT:
            await client.send_message(chat_id, response_text, reply_to=message_id)
            try:
                await add_reaction(chat_id, message_id)
            except Exception as e:
                logging.warning(f"‚ö† –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ä–µ–∞–∫—Ü–∏—é –≤ {chat_id}: {e}")
            logging.info(f"‚úÖ UserBot –æ—Ç–ø—Ä–∞–≤–∏–ª:\n{response_text}")
        else:
            await bot.send_message(chat_id, response_text, reply_to_message_id=message_id)
            try:
                await add_reaction(chat_id, message_id)
            except Exception as e:
                logging.warning(f"‚ö† –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ä–µ–∞–∫—Ü–∏—é –≤ {chat_id}: {e}")
            logging.info(f"‚úÖ Aiogram –æ—Ç–ø—Ä–∞–≤–∏–ª:\n{response_text}")

        cache[id_value].setdefault("responded_to", []).append((chat_id, message_id))
    else:
        cache[id_value].setdefault("pending_replies", []).append((chat_id, message_id))
        logging.info(f"üïì ID {id_value} –Ω–µ –Ω–∞–π–¥–µ–Ω. –û–∂–∏–¥–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.")


# –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–∞–∫—Ü–∏–∏
async def add_reaction(chat_id, message_id, emoji="‚ù§Ô∏è", SOURCE_CHAT=None):
    if chat_id == SOURCE_CHAT:
        return  # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —ç—Ç–æ—Ç —á–∞—Ç
    try:
        await asyncio.sleep(1)  # –î–∞–µ–º –≤—Ä–µ–º—è –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π —Ä–µ–∞–∫—Ü–∏–∏
        reaction = [ReactionEmoji(emoticon=emoji)]
        await client(SendReactionRequest(peer=chat_id, msg_id=message_id, reaction=reaction))
        logging.info(f"‚úÖ –†–µ–∞–∫—Ü–∏—è '{emoji}' –¥–æ–±–∞–≤–ª–µ–Ω–∞ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é {message_id} –≤ {chat_id}")
    except Exception as e:
        logging.error(f"‚ö† –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ä–µ–∞–∫—Ü–∏–∏: {e}")



# –§—É–Ω–∫—Ü–∏—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è ID
def extract_ids(text):
    if not text:
        return []

    # –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —Å–ª–æ–≤–∞/—Ç–æ–∫–µ–Ω—ã
    tokens = re.findall(r"[a-zA-Z0-9_\-]{4,}", text)

    ids = []
    for token in tokens:
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —è–≤–Ω–æ –æ–±—ã—á–Ω—ã–µ —Å–ª–æ–≤–∞
        if token.lower() in {"—É—Å–ø–µ—Ö", "–æ—à–∏–±–∫–∞", "clientid", "trackerid", "—Å—Ç–∞—Ç—É—Å"}:
            continue

        # –¥–ª–∏–Ω–Ω—ã–µ —á–∏—Å–ª–∞ (–æ—Ç 4 —Å–∏–º–≤–æ–ª–æ–≤)
        if token.isdigit() and 4 <= len(token) <= 20:
            ids.append(token)
            continue

        # –£—Å–ª–æ–≤–∏–µ 2: —Å–æ–¥–µ—Ä–∂–∏—Ç –±—É–∫–≤—ã –∏ —Ü–∏—Ñ—Ä—ã ‚Üí ID (–Ω–µ –ø—Ä–æ—Å—Ç–æ —Å–ª–æ–≤–æ)
        if any(c.isdigit() for c in token) and any(c.isalpha() for c in token):
            ids.append(token)
            continue

        # –£—Å–ª–æ–≤–∏–µ 3: –¥–ª–∏–Ω–Ω—ã–µ hex (24+ —Å–∏–º–≤–æ–ª–∞)
        if re.fullmatch(r"[a-f0-9]{24,64}", token, re.IGNORECASE):
            ids.append(token)
            continue

        # –£—Å–ª–æ–≤–∏–µ 4: UUID-—Ñ–æ—Ä–º–∞—Ç
        if re.fullmatch(r"[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}", token, re.IGNORECASE):
            ids.append(token)
            continue

    logging.info(f"–ù–∞–π–¥–µ–Ω–Ω—ã–µ ID: {ids}")
    return ids


# –¢–∞–π–º–µ—Ä –¥–ª—è —Å–≤–µ—Ä–∫–∏ –∫—ç—à–∞
async def cache_checker():
    while True:
        logging.info("üîÑ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—ç—à–∞ –∏ –æ—á–∏—Å—Ç–∫–∞...")
        cleanup_cache()
        await asyncio.sleep(600)  # –ö–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç


# –ó–∞–ø—É—Å–∫
async def main():
    logging.info("–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞...")
    asyncio.create_task(cache_checker())
    await client.start()
    await dp.start_polling(bot, skip_updates=True)


if __name__ == "__main__":
    asyncio.run(main())
